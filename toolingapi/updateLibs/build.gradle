/**
 * Tasks:
 *   - updateLibs : this will resolve and fetch the gradle tooling api jars and their transitive dependencies,
 *     copying them into the libs folder of the Eclipse bundle. It will also update the plugin manifest to add those
 *     files to runtime classpath of this plugin.
 *
 *   - updateEmbeddedLibsProperties : this updates 'embedded-libs.properties' file to list all the
 *     libs copied by updateLibs in the expected format by Martin's copytight ticket scripts.
 *
 *  Procedure for updating: (when working in STS)
 *    1) run the updateLibs task.
 *    2) in STS/Eclipse select PDE Tools >> Update Classpath to update org.springsource.ide.eclipse.gradle.core plugin's classpath.
 *        this step is hard to automate, is only required for building in the IDE, tycho build doesn't require this.
 *    3) (optional) manually fetch source jars and attach in 'Referenced Libararies'.
 *
 *  Procedure for updating: (when running maven tycho build on the build server):
 *     ensure that the following command is executed before running the actual maven tycho build:
 *     (cd org.springsource.ide.eclipse.gradle.core; ./gradlew)
 *     See integration-build.sh for an example.
 */

def bundleDir = file('../../org.springsource.ide.eclipse.gradle.toolingapi')

configurations {
    eclipseBundle
    eclipseBundleSource
}

dependencies {
	[
		"org.gradle:gradle-core:$project.gradleApiVersion",
		"org.gradle:gradle-tooling-api:$project.gradleApiVersion",
		"org.gradle:gradle-wrapper:$project.gradleApiVersion",
		"commons-collections:commons-collections:3.2.2",
		"org.slf4j:slf4j-simple:1.7.7"
	].each { dep ->
        eclipseBundle dep
        eclipseBundleSource "$dep:sources"
	}

    eclipseBundle project (':model')
    eclipseBundle project (':plugin'), { transitive = false }
}

task updateLibs(dependsOn: [
    ':model:publish',
    ':plugin:publish',
    'copyLibs',
    'updateEmbeddedLibsProperties',
    'updateManifest'
])

task copyLibs(type: Copy) {
	def libDir = new File("$bundleDir/lib")
	doFirst {
		libDir.listFiles().each { File f ->
			if (f.name.endsWith(".jar")) f.delete()
		}
	}
	into libDir
	from configurations.eclipseBundle
	from configurations.eclipseBundleSource
}

task updateEmbeddedLibsProperties << {
	configurations.eclipseBundle.resolvedConfiguration.resolvedArtifacts.inject(new Properties()) { props, res ->
        props.setProperty("${res.file.name}-name", res.moduleVersion.id.name)
        props.setProperty("${res.file.name}-version", res.moduleVersion.id.version)
		props
	}.store(
		new File("$bundleDir/embedded-libs.properties").newWriter(),
		'Generated by build.gradle task updateEmbeddedLibsProperties'
	)
}

task updateManifest << {
	def manifest = new File("$bundleDir/META-INF/MANIFEST.MF")
	def lines = manifest.readLines()
	
	manifest.withPrintWriter { out ->
		// copy file up to line with 'Bundle-ClassPath'
		lines.takeWhile { !it.startsWith('Bundle-ClassPath') }.each { out.println(it) }

        // the plugin jar is only needed by the Gradle daemon, not the Eclipse runtime
		out.println 'Bundle-ClassPath: .,'
		out.println configurations.eclipseBundle
                .findAll { it.name.endsWith('.jar') && !it.name.startsWith('plugin-') }
                .collect { " lib/$it.name" }.join(',\n')

		// copy rest of file beginning with 'Export-Package'
		lines.dropWhile { !it.startsWith('Export-Package') }.each { out.println(it) }
	}
}